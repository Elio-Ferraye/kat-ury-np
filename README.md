# README

This repository hosts a Python implementation of the Katětov–Urysohn plus Dual-Constraint Lifting (DCL) approach for a decision version of the Traveling Salesman Problem (TSP). The code encodes TSP constraints into a partial-distance system, then enforces coherence via local expansions reminiscent of difference constraints. The method relies on a repeated relaxation procedure analogous to Floyd–Warshall and handles both triangle and four-point (quadrangular) expansions, all in a single polynomial run without resorting to branching or enumeration. Although the TSP is an NP-complete problem, this program serves as an experimental demonstration of how a partial-distance plus DCL framework may handle certain instances efficiently in practice.

The following link provides a more detailed explanation of how the mathematical model works:

https://medium.com/@ferraye.elio/a-potential-approach-for-np-completeness-using-kat%C4%9Btov-urysohn-to-tackle-the-traveling-salesman-f730ae5ec208

There is no formal claim here that the method solves TSP in polynomial time for all cases. Instead, the code exemplifies how partial distances can be assigned to represent TSP arcs in intervals from zero up to the actual cost, thus allowing an iterative algorithm to choose or reject arcs implicitly through distance expansions. It also integrates an additional “Pivot” node that helps account for global costs by permitting intervals from city inputs and outputs to the pivot within certain large ranges. If the system stabilizes without negative cycles, the code returns “YES,” indicating a feasible tour with cost below the chosen threshold. Otherwise, the system identifies a contradiction, returning “NO.”

Each function is explained through comments placed throughout the file. Users should read the `PartialDistance` class for the logic of merging distance constraints, the `assign_partial_dist_tsp` function for assigning TSP arcs to partial-distance intervals, and the various expansions functions for how the code encodes triangle and quadrangular constraints. The solver runs in repeated passes, each time updating a matrix of difference constraints, raising a flag if additional refinements are needed, and exiting when stable or contradictory.

Multiple TSP instances are tested in a final `main()` function, including random cost matrices and Euclidian distances in two-dimensional coordinates. When using random costs, the code picks integer values in a specified range for each pair of cities. In Euclidian mode, the code picks random (x, y) points for each city and computes pairwise distances by standard geometry. The threshold K is chosen by the user to decide if the TSP instance might plausibly have a route under that limit. The approach does not manipulate or “tailor” the instance to make TSP appear simpler than it is: the random and geometric data remain unmodified apart from normal initialization steps. The code neither performs BFS nor enumerates all tours. Instead, it systematically implements expansions to reflect metric constraints, verifying whether a consistent partial-distance assignment can be found.

To run the code, one must have Python 3.9+ installed, along with `matplotlib` if visualization is desired. Executing `python kat-ury-TSP-Demo.py` triggers multiple test instances. The final or largest instance typically shows a two-dimensional route if the result is “YES.” The code logs times to measure how the solver scales with the number of cities. While no conclusion is drawn about every possible TSP, the results often exhibit polynomial-like growth within the tested range.

Users should note that this repository offers a practical illustration of partial-distance constraints and expansions for TSP, rather than a proof of universal polynomial-time solvability. It remains the user’s responsibility to investigate more advanced cases or theoretical underpinnings. Anyone interested in exploring or improving the code is welcome to clone the repository, open issues for questions, or submit pull requests. All expansions and difference constraints appear in the functions that create and relax `'sum<=0'` constraints; no hidden branching is present. Those familiar with difference-constraints frameworks will find much of this code straightforward to follow once they see how partial arcs are labeled and how expansions correspond to local metric properties.

The project is released under the Apache License 2.0 so that the code remains open and collaborative, yet credit is retained for the original authors. Refer to the license file for details. If you use or adapt this software in published work, attribution is appreciated. For additional references about partial distances, universal metric spaces, NP-complete problems, and difference-constraints solvers, one may consult works on Katětov–Urysohn extensions, standard TSP formulations, and standard textbooks on algorithms.
